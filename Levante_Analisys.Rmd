---
title: "![](figures/IEO-logo.jpg){width=6cm}"
output:
  bookdown::pdf_document2:
    includes:
      before_body: titulo.sty
    keep_tex: yes
    number_sections: no
    toc: true
    toc_depth: 3
bibliography: Donax.bib
csl: apa.csl
link-citations: yes
linkcolor: blue
indent: no
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhf{}
- \lfoot[\thepage]{}
- \rfoot[]{\thepage}
- \fontsize{12}{22}
- \selectfont
---
\pagebreak

```{r setup1, echo=FALSE}
set.seed(999)
rm(list = ls())
knitr::opts_chunk$set(echo=FALSE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = 'center',
                      dev = 'jpeg',
                      out.width="100%",
                      dpi = 300,
                      tidy = F,
                      tidy.opts = list(width.cutoff = 40))  # límite de ancho
#XQuartz is a mess, put this in your onload to default to cairo instead
options(bitmapType = "cairo") 
# (https://github.com/tidyverse/ggplot2/issues/2655)
# Lo mapas se hacen mas rapido
```


# Contexto

Análisis de los vientos de Levante y su relación con el reclutamiento de la coquina (*Donax trunculus*). Este estudio realiza un análisis detallado de los patrones de viento de Levante y Poniente a partir de datos meteorológicos recopilados entre 2013 y 2025. Se caracterizan aspectos clave como la frecuencia, duración e intensidad de estos eventos atmosféricos, con el objetivo de evaluar su posible influencia sobre variables poblacionales de la coquina *Donax trunculus*, una especie bivalva de importancia ecológica y pesquera en el litoral suratlántico español.


El objetivo principal de este trabajo es identificar y cuantificar los patrones de viento dominantes y analizar su relación con parámetros poblacionales de *Donax trunculus*. Para ello, se emplean datos de monitoreo biológico y pesquero obtenidos por el Instituto Español de Oceanografía (IEO-CSIC) en el marco del proyecto FEMP 04, con énfasis en las dinámicas de reclutamiento observadas en el Golfo de Cádiz.



\newpage

# Metodología

```{r libraries, echo=TRUE}
paquetes <- c(
  "readr", "dplyr", "lubridate", "stringr", "purrr",
  "ggplot2", "tidyr", "gridExtra", "viridis", "scales",
  "formatR", "ggpubr", "ggthemes", "kableExtra", "sjPlot", 
  "broom", "kableExtra"
  )


# Análisis de Series de Tiempo para Viento de Levante
# Carga de librerías necesarias
library(dplyr)
library(lubridate)
library(ggplot2)
library(forecast)
library(tseries)
library(seasonal)
library(zoo)
library(gridExtra)
library(corrplot)
library(plotly)


purrr::walk(paquetes, library, character.only = TRUE)
```

### Datos de viento

El acceso al servicio de descargas de **Puertos del Estado** se hace desde la página web de oceanografía de [Puertos del Estado](http://www.puertos.es/es-es/oceanografia/Paginas/portus.aspx)

Selección de estaciones y variables

* En el sistema **DescargaPortus**, se suele seleccionar entre varias estaciones meteorológicas costeras.
* Elegimos **cuatro puntos** ubicados frente a la costa del Parque de Doñana en la provincia de Cádiz (Figure \@ref(fig:mapa)).
* Seleccionamos datos de **viento**, en particular **velocidad** y **dirección**.

```{r mapa, out.width="95%", fig.cap= "Puntos seleccionados con la variable viento desde Puertos del Estado"}
knitr::include_graphics("figures/mapa.png") 
```


Período y frecuencia de datos

* Un **rango temporal** (por ejemplo 2013‑2025).
* Desechar valores nulos (ej. ‑999.9) siguiendo las recomendaciones de limpieza del manual.

Formato de descarga

  * `.csv` en formato tabular con columnas como:
  * Fecha (GMT)
  * Velocidad del viento (m/s)
  * Dirección del viento (grados meteorológicos)

Calidad de datos

  * Aplicamos filtros para descartar datos erróneos, como aquellos con velocidad negativa o direcciones fuera del rango 0–360º.

Procesamiento en R

* Finalmente, se importan en R usando funciones tipo `readr`, limpieza con `dplyr`, conversión de fechas con `lubridate`, etc.

Flujo de trabajo

| Etapa                       | Acción realizada                                      |
| --------------------------- | ----------------------------------------------------- |
| Selección de estaciones     | Cuatro puntos frente a Doñana (Cádiz)                 |
| Variables                   | Viento: velocidad y dirección                         |
| Periodo de interés          | Desde 2013 hasta el presente                          |
| Formato de descarga         | CSV / delimitado con primer registro meta             |
| Limpieza de datos           | Eliminación de “‑999.9” y NA                          |
| Conversión de formatos      | Fecha GMT a `POSIXct` o `Date`                        |


```{r data-loading, warning=FALSE, echo=TRUE}
directorio <- "~/IEO/wind-recruitment-Dtrunculus/data"
archivos <- c(
  "21405_40638_5028023_WIND_20130101124124_20250723114124.csv",
  "21405_40639_5027023_WIND_20130101124130_20250723114130.csv",
  "21405_40640_5029023_WIND_20130101124134_20250723114134.csv",
  "21405_40641_5030023_WIND_20130101124138_20250723114138.csv"
)
rutas_completas <- file.path(directorio, archivos)

#Funcion para leer todos los archivos.
leer_archivo_viento <- function(archivo) {
  readr::read_tsv(archivo, skip = 1,
                  col_names = c("fecha_raw", 
                                "velocidad_viento", 
                                "direccion_grados"),
                  show_col_types = FALSE) %>%
    mutate(
      fecha_raw = stringr::str_trim(fecha_raw),
      fecha = lubridate::parse_date_time(fecha_raw, orders = "Y m d H", tz = "UTC"),
      velocidad_viento = as.numeric(velocidad_viento),
      direccion_grados = as.numeric(direccion_grados)
    ) %>%
    dplyr::select(fecha, velocidad_viento, direccion_grados)
}

datos_viento <- purrr::map_dfr(rutas_completas, 
                               leer_archivo_viento)
```

Los registros de viento fueron clasificados en tres categorías: **Levante**, **Poniente** u **Otro**, en base a la siguiente regla propuesta por @bartolome1998viento:

$$
\text{tipo\_viento} =
\begin{cases}
\text{"Levante"} & \text{si } 4 \leq V < 40 \text{ y } 67.5^\circ \leq D \leq 157.5^\circ \\
\text{"Poniente"} & \text{si } 8 \leq V < 40 \text{ y } 247.5^\circ \leq D \leq 292.5^\circ \\
\text{"Otro"} & \text{en cualquier otro caso}
\end{cases}
$$
Donde:

* $V$ es la **velocidad del viento** en m/s.
* $D$ es la **dirección del viento** en grados meteorológicos.

Esta clasificación se implementó en R con `case_when()` para etiquetar automáticamente cada observación horaria.

```{r data-cleaning}
datos_limpios <- datos_viento %>%
  filter(!is.na(fecha),
         !is.na(velocidad_viento),
         !is.na(direccion_grados),
         velocidad_viento != -999.9,
         direccion_grados != -999.9)
```

```{r wind-classification, echo=TRUE}
# Clasificar los datos de viento
datos_clasificados <- datos_limpios %>%
  mutate(
    tipo_viento = case_when(
      velocidad_viento >= 4 & velocidad_viento <= 40 &
        direccion_grados >= 67.5 & direccion_grados <= 157.5 ~ "Levante",
      velocidad_viento >= 8 & velocidad_viento <= 40 &
        direccion_grados >= 247.5 & direccion_grados <= 292.5 ~ "Poniente",
      TRUE ~ "Otro"
    )
  )
```

En terminos direccionales, la rosa de los vientos queda clasificada de la siguiente forma:

```{r windrose, fig.cap= "Rosa de vientos mostrando la clasificación de sectores para Levante y Poniente"}
sectores_clasificacion <- data.frame(
  sector = c("Norte", "Noreste", "Este",
             "Sureste", "Sur", "Suroeste", "Oeste", "Noroeste"),
  grados_inicio = c(337.5, 22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5),
  grados_fin = c(22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5),
  tipo_viento = c("Otro", "Otro", "Levante", "Levante",
                  "Otro", "Otro", "Poniente", "Otro"),
  valor = 1,
  etiqueta_grados = c("337.5°-22.5°", 
                      "22.5°-67.5°", 
                      "67.5°-112.5°",
                      "112.5°-157.5°", 
                      "157.5°-202.5°", 
                      "202.5°-247.5°",
                      "247.5°-292.5°",
                      "292.5°-337.5°")
) %>%
  mutate(
    sector = factor(sector, levels = c("Norte", "Noreste", "Este", "Sureste", 
                                       "Sur", "Suroeste", "Oeste", "Noroeste")),
    color_sector = case_when(
      tipo_viento == "Levante" ~ "#E74C3C",   
      tipo_viento == "Poniente" ~ "#3498DB",    
      TRUE ~ "#95A5A6"                        
    )
  )

rosa_polar_clasificacion <- ggplot(sectores_clasificacion, 
                                   aes(x = sector, 
                                       y = valor, 
                                       fill = tipo_viento)) +
  geom_col(width = 0.9, color = "white", size = 1) +
  scale_fill_manual(
    values = c("Levante" = "#E74C3C", 
               "Poniente" = "#3498DB",
               "Otro" = "#95A5A6"),
    name = "Tipo de viento"
  ) +
  geom_text(aes(y = 1.15, label = paste0(sector, "\n", etiqueta_grados)), 
            color = "black", size = 3,
            fontface = "bold", 
            lineheight = 0.8) +
  labs(title = "", x = "", y = "") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 20)),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank(),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 11)
  ) +
  coord_polar(theta = "x", start = -pi/8, direction = 1) +
  theme(
    panel.grid.major.x = element_line(color = "lightblue", 
                                      linetype = "dotted"),
    panel.grid.major.y = element_line(color = "lightblue", 
                                      linetype = "dotted"),
    axis.text.x = element_blank()
  ) +
  scale_y_continuous(limits = c(0, 1.3))

rosa_polar_clasificacion
```


## Datos de variables poblacionales de coquina

Utilizaremos el indice de reclutamiento que provien e de las tallas , calculado como la proporcion de individuos `< 15 mm`.


```{r warning=FALSE}
datos <- readRDS("data/index_recruit_2013_2025.RDS")
```

\newpage


# Resultados


Analizamos la frecuencia de eventos de levante y poniente en la Figura \@ref(fig:frequency-analysis2).

```{r frequency-analysis, fig.cap="Distribución de velocidades del viento y frecuencia por dirección cardinal"}
# Función para clasificar en puntos cardinales
puntos_cardinales <- function(grados) {
  case_when(
    grados >= 337.5 | grados < 22.5 ~ "N",
    grados >= 22.5 & grados < 67.5 ~ "NE",
    grados >= 67.5 & grados < 112.5 ~ "E",
    grados >= 112.5 & grados < 157.5 ~ "SE",
    grados >= 157.5 & grados < 202.5 ~ "S",
    grados >= 202.5 & grados < 247.5 ~ "SW",
    grados >= 247.5 & grados < 292.5 ~ "W",
    grados >= 292.5 & grados < 337.5 ~ "NW"
  )
}

datos_vel <- datos_clasificados %>%
  filter(!is.na(velocidad_viento)) %>%
  mutate(clase_velocidad = cut(
    velocidad_viento,
    breaks = seq(0, 24, by = 3),
    include.lowest = TRUE,
    right = FALSE
  )) %>%
  count(clase_velocidad) %>%
  mutate(porcentaje = 100 * n / sum(n))

g1 <- ggplot(datos_vel, aes(x = clase_velocidad, y = porcentaje)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "black") +
  labs(x = "Velocidad Media (m/s)", y = "Frecuencia %") +
  theme_minimal(base_size = 13) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))


datos_dir <- datos_clasificados %>%
  filter(!is.na(direccion_grados)) %>%
  mutate(
    direccion_cardinal = puntos_cardinales(direccion_grados),
    tipo_viento = case_when(
      direccion_cardinal %in% c("E", "SE") ~ "Levante",
      direccion_cardinal %in% c("W") ~ "Poniente",
      TRUE ~ "Otro"
    )
  ) %>%
  count(direccion_cardinal, tipo_viento) %>%
  mutate(
    porcentaje = 100 * n / sum(n),
    direccion_cardinal = factor(
      direccion_cardinal,
      levels = c("N", "NE", "E", "SE", "S", "SW", "W", "NW")
    )
  )

g2 <- ggplot(datos_dir, aes(x = direccion_cardinal, 
                            y = porcentaje, 
                            fill = tipo_viento)) +
  geom_bar(stat = "identity", color = "black") +
  labs(x = "Dirección de Procedencia", y = "Frecuencia %") +
  scale_fill_manual(values = c("Levante" = "#d62728",
                               "Poniente" = "#1f77b4",
                               "Otro" = "#95A5A6")) +
  coord_polar(theta = "x") +
  theme_minimal(base_size = 13) +
  theme(legend.position = "bottom")
```

```{r frequency-analysis2,out.width="60%", fig.height=6, fig.width=4, fig.cap="Distribución de velocidades del viento y frecuencia por dirección cardinal"}
gridExtra::grid.arrange(g1, g2, ncol = 1)
```

\newpage

También visualizamos la relación entre intensisdad y dias con levante y poniente en la Figura \@ref(fig:intvel)

```{r}
datos_eventos <- datos_clasificados %>%
  filter(tipo_viento %in% c("Levante", "Poniente")) %>%
  arrange(fecha) %>%
  group_by(tipo_viento) %>%
  mutate(
    dif_hora = as.numeric(difftime(fecha, lag(fecha), units = "hours")),
    nueva_serie = is.na(dif_hora) | dif_hora > 1,
    grupo_evento = cumsum(nueva_serie)
  ) %>%
  ungroup()

# Calcular duración y características por evento
resumen_eventos <- datos_eventos %>%
  group_by(tipo_viento, grupo_evento) %>%
  summarise(
    inicio = min(fecha),
    fin = max(fecha),
    duracion_dias = as.numeric(difftime(fin, inicio, units = "days")) + 1,
    velocidad_media_episodio = mean(velocidad_viento, na.rm = TRUE),
    velocidad_maxima = max(velocidad_viento, na.rm = TRUE),
    .groups = "drop"
  )
```


```{r intvel, out.width="60%", fig.cap="Relación entre intensisdad y dias con levante y poniente"}
grafico_duracion_intensidad <- ggplot(resumen_eventos,
                                      aes(x = duracion_dias, 
                                          y = velocidad_media_episodio,
                                          color = tipo_viento, 
                                          size = velocidad_maxima)) +
  geom_point(alpha = 0.5) +
  scale_color_manual(values = c("Levante" = "#E74C3C", "Poniente" = "#3498DB")) +
  scale_size_continuous(name = "Vel. Máxima\n(m/s)", range = c(1, 8)) +
  labs(
    x = "Duración (días)",
    y = "Velocidad Media del Episodio (m/s)",
    color = "Tipo de Viento"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11),
    legend.position = "none"
  ) +
  facet_wrap(~tipo_viento)

grafico_duracion_intensidad
```
Promedio por mes de los días con levante y poniente a través de los meses en la Figura \@ref(fig:intvel2).

```{r intvel2, out.width="60%", fig.cap="Relación entre intensisdad y dias con levante y poniente"}
# Crear año, mes, y día como columnas separadas
resumen_dias <- datos_clasificados %>%
  mutate(
    fecha_dia = as_date(fecha),
    año = year(fecha),
    mes = month(fecha, label = TRUE, abbr = TRUE)
  ) %>%
  filter(tipo_viento %in% c("Levante", "Poniente")) %>%
  group_by(año, mes, tipo_viento, fecha_dia) %>%
  summarise(.groups = "drop") %>%
  count(año, mes, tipo_viento, name = "dias_con_evento")

ggplot(resumen_dias, aes(x = mes, 
                         y = dias_con_evento, 
                         fill = tipo_viento)) +
  geom_bar(stat = "identity", position = "dodge") +
  #facet_wrap(~año, ncol = 4) +
  scale_fill_manual(values = c("Levante" = "red", 
                               "Poniente" = "blue")) +
  labs(
    x = "",
    y = "Días con evento de viento",
    fill = "Tipo de viento"
  ) +
  theme_minimal(base_size = 12)+
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, 
                                   hjust = 1),
        legend.position = "bottom")+
  coord_flip()
```
\newpage

Ahora por año y por mes

```{r fig.height=8, fig.width=7, out.width="100%"}

grafico_levante <- resumen_dias %>%
  filter(tipo_viento == "Levante") %>%
  ggplot(aes(x = mes, y = dias_con_evento)) +
  geom_col(fill = "#E74C3C", width = 0.6) +
  labs(
    title = "LEVANTE",
    y = "Días con eventos",
    x = NULL
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
    axis.text.x = element_text(angle = 90, hjust = 1, size = 9),
    axis.text.y = element_text(size = 9),
    axis.title.y = element_text(size = 10),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 10, face = "bold")
  ) +
  facet_wrap(~año, ncol = 3) +
  geom_text(aes(label = dias_con_evento), 
            hjust = -0.3, size = 3) +
  coord_flip()

# Crear gráfico para Poniente
grafico_poniente <- resumen_dias %>%
  filter(tipo_viento == "Poniente") %>%
  ggplot(aes(x = mes, y = dias_con_evento)) +
  geom_col(fill = "#3498DB", width = 0.6) +
  labs(
    title = "PONIENTE",
    y = "Días con eventos",
    x = NULL
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
    axis.text.x = element_text(angle = 90, hjust = 1, size = 9),
    axis.text.y = element_text(size = 9),
    axis.title.y = element_text(size = 10),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 10, face = "bold")
  ) +
  facet_wrap(~año, ncol = 3) +
  geom_text(aes(label = dias_con_evento), 
            hjust = -0.5, size = 3) +
  coord_flip()

# Combinar ambos gráficos
grafico_combinado <- grid.arrange(grafico_levante, 
                                  grafico_poniente, ncol = 2)
```

```{r fig.height=4, fig.width=6}
levante_data <- resumen_dias %>% filter(tipo_viento == "Levante")
poniente_data <- resumen_dias %>% filter(tipo_viento == "Poniente")
p1 <- ggplot(levante_data, aes(x = mes, y = factor(año), fill = dias_con_evento)) +
  geom_tile(color = "white") +
  scale_fill_gradientn(
    colors = c("#D3D3D3", "#E74C3C"),
    name = "Días\nLevante"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid = element_blank()
  )

# Heatmap Poniente
p2 <- ggplot(poniente_data, aes(x = mes, y = factor(año), fill = dias_con_evento)) +
  geom_tile(color = "white") +
  scale_fill_gradientn(
    colors = c("#D3D3D3", "#3498DB"),
    name = "Días\nPoniente"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid = element_blank()
  )

# Mostrar juntos
egg::ggarrange(p1, p2, ncol = 2)

```


```{r}
serie_mensual <- resumen_dias %>%
  mutate(
    mes_num = match(mes, month.abb),  # Convertir mes abreviado a número
    año_mes = as.Date(paste(año, mes_num, "01", sep = "-"))
  )
# Filtrar datos por tipo de viento
serie_levante <- serie_mensual %>% filter(tipo_viento == "Levante")
serie_poniente <- serie_mensual %>% filter(tipo_viento == "Poniente")

# Gráfico Levante
g_levante <- ggplot(serie_levante, 
                    aes(x = año_mes, 
                        y = dias_con_evento)) +
  geom_point(color = "#E74C3C", size = 2) +
  geom_smooth(method = "loess", color = "#E74C3C", 
              span=0.1) +
  labs(title = "Levante", 
       x = "Fecha", 
       y = "N° de Eventos por Mes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "6 months")

# Gráfico Poniente
g_poniente <- ggplot(serie_poniente, 
                     aes(x = año_mes, 
                         y = dias_con_evento)) +
  geom_point(color = "#3498DB", size = 2) +
  geom_smooth(method = "loess", color = "#3498DB", 
              span=0.1) +
  labs(title = "Poniente", 
       x = "Fecha", 
       y = "N° de Eventos por Mes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "6 months")

fig_comb <- ggarrange(
  g_levante, g_poniente,
  ncol = 1, nrow = 2,
  common.legend = FALSE
)
fig_comb

```


```{r}
# PASO 9: Preparar datos para serie anual
# Agrupar por año y tipo de viento
serie_anual <- resumen_dias %>%
  group_by(año, tipo_viento) %>%
  summarise(dias_con_evento = sum(dias_con_evento), .groups = "drop")

# Crear gráfico de líneas anual
grafico_lineas_anual <- ggplot(serie_anual, 
                               aes(x = año,
                                   y = dias_con_evento, 
                                   color = tipo_viento)) +
  geom_point(size = 2) +
  geom_smooth(method = "lm")+
  scale_color_manual(values = c("Levante" = "#E74C3C", "Poniente" = "#3498DB")) +
  labs(
    x = "",
    y = "Número de Días con Evento",
    color = "Tipo de Viento"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, face = "bold"),
    plot.subtitle = element_text(size = 11),
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  scale_x_continuous(breaks = 2013:2024)+
  xlim(2013,2024)
# Mostrar gráfico
grafico_lineas_anual
```
\newpage

### Series temporales del monitoreo poblacional de coquina

```{r warning=FALSE, fig.height=4, fig.width=8}
ggplot(datos %>% 
         drop_na(), aes(x = mes_num, y = meand15)) +
  geom_point(color = "#2C3E50", 
             alpha = 0.7, 
             size = 2) +
  geom_smooth(method = "lm", se = T) +  
  scale_x_continuous(
    breaks = 1:12,
    labels = month.abb,
    limits = c(1, 12)
  ) +
  labs(
    x = "",
    y = "d15"
  ) +
  theme_few(base_size = 8) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5),
    panel.grid.minor = element_blank()
  ) +
  facet_wrap(~ANO, nrow = 2) +
  ylim(0, 75)

```

El plot muestra una marcada estacionalidad de los reclutamientos, con un pulso posterior a los meses estivales como lo indica @Delgado2018 en la Figura \@ref(fig:ciclo).

```{r ciclo, out.width="75%", fig.cap= "Schematic representation of the reproductive cycle, periods of emission of gametes and related recruitment events in populations of D. trunculus from SW Spain. Black symbols represent the C1 cohort (from February-March) and grey symbols represent the C2 cohort (from July)"}
knitr::include_graphics("figures/ciclo.png") 
```
\newpage

## Modelos de correlacion entre Reclutamiento y Viento de Levante

Uno las bases que estan en los objetos `serie_levante` y `datos`

```{r}
glimpse(serie_levante)
glimpse(datos)
```

```{r}
tabla_d15 <- datos %>%
  rename(
    año = ANO
  )
datos_unidos <- serie_levante %>%
  left_join(tabla_d15, by = c("año", "mes_num"))

```


```{r out.width="75%", fig.cap="Distribución de variablees objetivo para el análisis de correlación"}
hist(datos_unidos$dias_con_evento)
hist(datos_unidos$meand15)
```


```{r}
# Serie temporal para ver patrones estacionales
ggplot(datos_unidos, aes(x = año_mes)) +
  geom_line(aes(y = dias_con_evento, 
                color = "Días Levante")) +
  geom_line(aes(y = meand15, 
                color = "Reclutamiento")) +
  scale_y_continuous(sec.axis = sec_axis(~., 
                                         name = "Reclutamiento")) +
  labs(title = "", x = "") +
  theme_minimal()+
  theme(legend.position = "bottom")
```

```{r}
# Remover NAs para el análisis
levante_clean <- datos_unidos %>% 
  filter(!is.na(meand15))
```


```{r}
# Modelo lineal simple
modelo <- lm(meand15 ~ dias_con_evento, data = levante_clean)

resumen <- broom::tidy(modelo, conf.int = TRUE)

resumen <- resumen %>%
  mutate(across(c(estimate, std.error, conf.low, conf.high, p.value), ~round(.x, 3)))
colnames(resumen) <- c("Término", 
                       "Coeficiente", 
                       "Error estándar",
                       "Estadístico t", "Valor p",
                       "IC inferior 95%", 
                       "IC superior 95%")

resumen %>%
  kbl(caption = "Modelo lineal simple de reclutamiento de coquina y viento de levante") %>%
  kable_styling(latex_options = c("striped", "hold_position"))
```
En primera instancia, no se observa una correlación lineal significativa entre el viento de levante y el reclutamiento, con un coeficiente de determinación muy bajo (R2  = 0.021), indicando escaso poder explicativo.

A continuación, se procede a analizar la relación entre estas variables en una escala temporal diferente, específicamente a nivel semestral, evaluando la posible influencia del viento de levante sobre el reclutamiento de coquina.

```{r}
# 1. AGREGACIÓN A ESCALA SEMESTRAL
datos_semestral <- levante_clean %>%
  mutate(
    # Crear variable semestre
    semestre = case_when(
      mes %in% c("Jan", "Feb", "Mar", "Apr", "May", "Jun") ~ 1,
      mes %in% c("Jul", "Aug", "Sep", "Oct", "Nov", "Dec") ~ 2
    ),
    # Crear identificador año-semestre
    año_semestre = paste(año, semestre, sep = "_")
  ) %>%
  # Agrupar y sumarizar por semestre
  group_by(año, semestre, año_semestre) %>%
  summarise(
    # Sumar días de viento en el semestre
    dias_viento_semestre = sum(dias_con_evento, na.rm = TRUE),
    # Promedio de reclutamiento (removiendo NAs)
    reclutamiento_promedio = mean(meand15, na.rm = TRUE),
    # Mediana de reclutamiento 
    reclutamiento_mediana = median(meand15, na.rm = TRUE),
    # Suma de reclutamiento
    reclutamiento_suma = sum(meand15, na.rm = TRUE),
    # Número de observaciones válidas
    n_obs_validas = sum(!is.na(meand15)),
    .groups = 'drop'
  ) %>%
  # Solo mantener semestres con datos válidos de reclutamiento
  filter(n_obs_validas > 0, !is.infinite(reclutamiento_promedio))
```

```{r}
datos_semestral$fecha_semestre <- as.Date(paste(datos_semestral$año, 
                                               ifelse(datos_semestral$semestre == 1, "06", "12"), 
                                               "01", sep = "-"))

p2 <- ggplot(datos_semestral, aes(x = fecha_semestre)) +
  geom_line(aes(y = scale(dias_viento_semestre), 
                color = "Viento Levante"), 
            size = 1) +
  geom_line(aes(y = scale(reclutamiento_promedio), 
                color = "Reclutamiento"), 
            size = 1) +
  labs(
    title = "Series temporales semestrales (estandarizadas)",
    x = "Fecha (semestre)",
    y = "Valores estandarizados",
    color = "Variable"
  ) +
  scale_color_manual(values = c("Viento Levante" = "steelblue", "Reclutamiento" = "darkred")) +
  theme_minimal()

print(p2)
```


```{r}
# Correlación por semestre
cor_por_semestre <- datos_semestral %>%
  group_by(semestre) %>%
  summarise(
    correlacion = cor(dias_viento_semestre, reclutamiento_promedio, use = "complete.obs"),
    n_semestres = n(),
    .groups = 'drop'
  )

print("\n=== CORRELACIÓN POR SEMESTRE ===")
kableExtra::kbl(cor_por_semestre) %>%
  kable_styling(latex_options = c("striped", "hold_position"))

```

### Modelos semestrales con interacción

```{r}
# Modelo lineal semestral
modelo_lineal_sem <- lm(reclutamiento_promedio ~ dias_viento_semestre, 
                       data = datos_semestral)

# Modelo cuadrático semestral  
modelo_cuad_sem <- lm(reclutamiento_promedio ~ dias_viento_semestre + I(dias_viento_semestre^2), 
                     data = datos_semestral)

# Modelo con efecto del semestre
modelo_semestre <- lm(reclutamiento_promedio ~ dias_viento_semestre + factor(semestre), 
                     data = datos_semestral)

# Modelo con interacción semestre
modelo_interaccion_sem <- lm(reclutamiento_promedio ~ dias_viento_semestre * factor(semestre), 
                           data = datos_semestral)
modelos <- list(
  "Lineal" = modelo_lineal_sem,
  "Cuadrático" = modelo_cuad_sem, 
  "Con semestre" = modelo_semestre,
  "Interacción" = modelo_interaccion_sem
)

# Tabla comparativa
comparacion <- data.frame(
  Modelo = names(modelos),
  R2_ajustado = sapply(modelos, function(m) summary(m)$adj.r.squared),
  AIC = sapply(modelos, AIC),
  p_value = sapply(modelos, function(m) {
    f_stat <- summary(m)$fstatistic
    if(!is.null(f_stat)) pf(f_stat[1], f_stat[2], f_stat[3], lower.tail = FALSE) else NA
  })
)

kableExtra::kbl(comparacion) %>%
  kable_styling(latex_options = c("striped", "hold_position"))
```

Figura \@ref(fig:resutlm)

```{r resultlm, fig.caption = "Cada punto = un semestre (n=20). Modelo: Reclutamiento ~ Viento × Semestre"}
# Crear datos para las líneas de regresión
rango_viento <- seq(min(datos_semestral$dias_viento_semestre), 
                   max(datos_semestral$dias_viento_semestre), 
                   length.out = 100)

# Predicciones para cada semestre
# Crear el data.frame para predecir
nuevo_df <- expand.grid(
  dias_viento_semestre = rango_viento,
  semestre = c(1, 2)
)
# Importante: convertir 'semestre' a factor para que encaje con el modelo
nuevo_df$semestre <- factor(nuevo_df$semestre)

# Usar el modelo con interacción
nuevo_df$reclutamiento_pred <- predict(modelo_interaccion_sem, newdata = nuevo_df)

# Gráfico principal
p_final <- ggplot() +
  # Puntos observados
    geom_point(data = datos_semestral, 
             aes(x = dias_viento_semestre, y = reclutamiento_promedio, 
                 color = factor(semestre), shape = factor(semestre)), 
             size = 4, alpha = 0.8) +
  
  # # Líneas de regresión
    geom_line(data = nuevo_df, 
            aes(x = dias_viento_semestre, 
                y = reclutamiento_pred,
                color = factor(semestre)), 
            size = 1.2) +
  # Intervalos de confianza
  geom_smooth(data = filter(datos_semestral, semestre == 1),
              aes(x = dias_viento_semestre, y = reclutamiento_promedio),
              method = "lm", se = TRUE, alpha = 0.2, color = "darkred") +
  
  geom_smooth(data = filter(datos_semestral, semestre == 2),
              aes(x = dias_viento_semestre, y = reclutamiento_promedio),
              method = "lm", se = TRUE, alpha = 0.2, color = "steelblue") +
  
  # Anotaciones con las ecuaciones
  annotate("text", x = 65, y = 20, 
           label = "Semestre 1 (Ene-Jun):\nReclut = 21.8 - 0.16×Viento\n(Efecto NEGATIVO)", 
           color = "darkred", size = 3.5, hjust = 0, fontface = "bold") +
  
  annotate("text", x = 35, y = 40, 
           label = "Semestre 2 (Jul-Dic):\nReclut = 10.2 + 0.40×Viento\n(Efecto POSITIVO)", 
           color = "steelblue", size = 3.5, hjust = 0, fontface = "bold") +
  
  # Configuración estética
  scale_color_manual(values = c("1" = "darkred", "2" = "steelblue"),
                     labels = c("1" = "Ene-Jun (Reproductivo)", 
                               "2" = "Jul-Dic (Crecimiento)")) +
  
  scale_shape_manual(values = c("1" = 16, "2" = 17),
                     labels = c("1" = "Ene-Jun (Reproductivo)", 
                               "2" = "Jul-Dic (Crecimiento)")) +
  
  labs(
    title = "Efectos opuestos del viento de Levante según el período del año",
    subtitle = "R² = 41% | p < 0.01 | Interacción p = 0.075",
    x = "Días de viento de Levante por semestre",
    y = "Reclutamiento promedio de coquina",
    color = "Período",
    shape = "Período"
  ) +
  
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11, color = "gray40"),
    legend.title = element_text(face = "bold")
  )

p_final
```


El gráfico muestra que la influencia del viento de Levante sobre el reclutamiento de coquina (*Donax trunculus*) varía significativamente según el semestre del año, revelando una interacción estacional. Durante el primer semestre (enero a junio), que corresponde al periodo reproductivo, se observa un efecto negativo, es decir, a mayor número de días con viento de Levante, menor es el reclutamiento promedio. Esto sugiere que estos vientos podrían interferir con el éxito reproductivo, afectando la dispersión larval o la retención costera, o generando condiciones ambientales desfavorables en el hábitat de asentamiento, como cambios en temperatura, salinidad o estructura del sedimento. En cambio, en el segundo semestre (julio a diciembre), el efecto es positivo: un mayor número de días con viento se asocia con un mayor reclutamiento, lo que podría deberse a que estos vientos favorecen la acumulación de materia orgánica o sedimentos en las playas, mejorando las condiciones de crecimiento y refugio para los juveniles ya asentados. Esta inversión del efecto sugiere que el mismo factor ambiental puede tener consecuencias opuestas según el momento del ciclo de vida en que actúa, lo que subraya la importancia de considerar la estacionalidad en la evaluación del reclutamiento y en la gestión pesquera de esta especie.


### Series de Tiempo 


Crear métricas anuales del viento Levante
```{r}
# PASO 1: Crear serie_diaria desde datos originales
# Filtrar solo datos de viento Levante
datos_levante <- datos_clasificados %>%
  filter(tipo_viento == "Levante") %>%
  arrange(fecha)

# Agregar datos por día (promedio diario)
serie_diaria <- datos_levante %>%
  mutate(fecha_dia = as.Date(fecha)) %>%
  group_by(fecha_dia) %>%
  summarise(
    velocidad_promedio = mean(velocidad_viento, na.rm = TRUE),
    direccion_promedio = mean(direccion_grados, na.rm = TRUE),
    n_observaciones = n(),
    .groups = 'drop'
  ) %>%
  filter(!is.na(velocidad_promedio))
```


```{r}
# Crear datos anuales agregados
viento_anual <- serie_diaria %>%
  mutate(año = year(fecha_dia)) %>%
  group_by(año) %>%
  summarise(
    velocidad_media = mean(velocidad_promedio, na.rm = TRUE),
    velocidad_max = max(velocidad_promedio, na.rm = TRUE),
    velocidad_min = min(velocidad_promedio, na.rm = TRUE),
    velocidad_percentil95 = quantile(velocidad_promedio, 0.95, na.rm = TRUE),
    velocidad_percentil75 = quantile(velocidad_promedio, 0.75, na.rm = TRUE),
    velocidad_percentil25 = quantile(velocidad_promedio, 0.25, na.rm = TRUE),
    dias_viento_fuerte = sum(velocidad_promedio > quantile(velocidad_promedio, 0.8, na.rm = TRUE), na.rm = TRUE),
    variabilidad = sd(velocidad_promedio, na.rm = TRUE),
    n_dias = n(),
    .groups = 'drop'
  )   
summary(viento_anual)
```



**Velocidad media del viento anual**

Es el promedio de las velocidades diarias dentro de un año:
$$
\bar{v} = \frac{1}{n} \sum_{i=1}^{n} v_i
$$

Donde $v_i$ es la velocidad del viento el día $i$ y $n$ es el número de días del año.

 **Velocidad máxima del viento anual**
   Valor máximo observado en el año:

$$
v_{\text{max}} = \max(v_1, v_2, \dots, v_n)
$$
**Velocidad mínima del viento anual**
Valor mínimo observado en el año:

$$
v_{\text{min}} = \min(v_1, v_2, \dots, v_n)
$$

**Percentil 95 (P95)**
 Valor por debajo del cual cae el 95% de las observaciones:

$$
P_{95} = \text{percentil}_{95}(v_1, v_2, \dots, v_n)
$$

**Percentil 75 (P75)**
   Valor por debajo del cual cae el 75% de las observaciones:

$$
P_{75} = \text{percentil}_{75}(v_1, v_2, \dots, v_n)
$$

**Percentil 25 (P25)**
Valor por debajo del cual cae el 25% de las observaciones:

$$
P_{25} = \text{percentil}_{25}(v_1, v_2, \dots, v_n)
$$

**Días con viento fuerte (por encima del percentil 80 del año)**
   Cuenta de días cuya velocidad supera el percentil 80:

$$
D_{80} = \sum_{i=1}^{n} \mathbb{1}(v_i > P_{80})
$$

Donde $\mathbb{1}$ es la función indicadora y $P_{80}$ es el percentil 80 de la serie del año.

**Variabilidad (desviación estándar)**
Medida de dispersión en torno a la media:

$$
\sigma = \sqrt{\frac{1}{n - 1} \sum_{i=1}^{n} (v_i - \bar{v})^2}
$$
**Número de días con datos válidos (n)**
Total de observaciones disponibles en el año:

$$
n = \text{número de días con datos}
$$


Ahora las graficas  con estas metricas del levsante como análisis exploratorio.

```{r}
p1 <- ggplot(viento_anual, aes(x = año, y = velocidad_media)) +
  geom_line(color = "steelblue", size = 1.2) +
  geom_point(color = "darkblue", size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "red", alpha = 0.3) +
  labs(title = "Velocidad Media Anual - Viento Levante",
       x = "", 
       y = "Velocidad Media (m/s)")+
  theme_minimal() +
    theme(plot.title = element_text(size = 10),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_continuous(breaks = viento_anual$año)
# 2. Rangos de variabilidad anual (boxplot-style)
p2 <- ggplot(viento_anual, aes(x = factor(año))) +
  geom_errorbar(aes(ymin = velocidad_min, ymax = velocidad_max), 
                width = 0.2, color = "gray60") +
  geom_errorbar(aes(ymin = velocidad_percentil25, ymax = velocidad_percentil75), 
                width = 0.4, color = "steelblue", size = 1.5) +
  geom_point(aes(y = velocidad_media), color = "darkred", size = 3) +
  labs(title = "Variabilidad Anual del Viento Levante",
       x = "", 
       y = "Velocidad (m/s)")+
  theme_minimal() +
    theme(plot.title = element_text(size = 10),
        axis.text.x = element_text(angle = 90, hjust = 1))

# 3. Días con viento fuerte por año
p3 <- ggplot(viento_anual, aes(x = año, y = dias_viento_fuerte)) +
  geom_col(fill = "orange", alpha = 0.7, color = "darkorange") +
  geom_smooth(method = "lm", se = TRUE, color = "red", alpha = 0.3) +
  labs(title = "Días con Viento Fuerte por Año (Días con velocidad > percentil 80)",
       x = "", 
       y = "Número de días (>P80)")+
  theme_minimal() +
  theme(plot.title = element_text(size = 10),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_continuous(breaks = viento_anual$año)
# 4. Variabilidad interanual (desviación estándar)
p4 <- ggplot(viento_anual, aes(x = año, y = variabilidad)) +
  geom_line(color = "purple", size = 1.2) +
  geom_point(color = "darkmagenta", size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "red", alpha = 0.3) +
  labs(title = "Variabilidad Intra-anual del Viento",
       x = "", 
       y = "Desviación Estándar (m/s)")+
  theme_minimal() +
  theme(plot.title = element_text(size = 10),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_x_continuous(breaks = viento_anual$año)
```


```{r}
# 5. Panel combinado
p_combinado <- grid.arrange(p1, p2, p3, p4, ncol = 2)
```


 Crear objeto `ts`

```{r}
# Agregar datos por día (promedio diario)
serie_diaria <- datos_levante %>%
  mutate(fecha_dia = as.Date(fecha)) %>%
  group_by(fecha_dia) %>%
  summarise(
    velocidad_promedio = mean(velocidad_viento, na.rm = TRUE),
    direccion_promedio = mean(direccion_grados, na.rm = TRUE),
    n_observaciones = n(),
    .groups = 'drop'
  ) %>%
  filter(!is.na(velocidad_promedio))

# Crear serie temporal
ts_levante <- ts(serie_diaria$velocidad_promedio, 
                 start = c(year(min(serie_diaria$fecha_dia)), yday(min(serie_diaria$fecha_dia))),
                 frequency = 365.25)

```


```{r}
# Visualización de la serie temporal
p1 <- autoplot(ts_levante) +
  labs(title = "Serie Temporal - Velocidad Promedio Viento Levante",
       x = "Tiempo", y = "Velocidad (m/s)") +
  theme_minimal()
p1
```


```{r}
# Test de estacionariedad - Augmented Dickey-Fuller
adf_test <- adf.test(ts_levante, alternative = "stationary")
cat("Test ADF p-value:", adf_test$p.value, "\n")
if(adf_test$p.value < 0.05) {
  cat("La serie ES estacionaria (p < 0.05)\n")
} else {
  cat("La serie NO es estacionaria (p >= 0.05)\n")
}
```
El test de estacionariedad Augmented Dickey-Fuller (ADF) aplicado a la serie temporal `ts_levante` arrojó un p-valor de 0.01, que es menor al umbral comúnmente utilizado de 0.05. Esto indica que podemos rechazar la hipótesis nula de que la serie tiene una raíz unitaria (es decir, no es estacionaria). Por lo tanto, concluimos que la serie `ts_levante` es estacionaria, lo que significa que sus propiedades estadísticas, como la media y la varianza, se mantienen constantes en el tiempo. Esto es fundamental para muchos análisis de series temporales y modelos predictivos que asumen estacionariedad.


```{r}
# Test de normalidad Jarque-Bera
jb_test <- jarque.bera.test(as.numeric(ts_levante))
jb_test
```
El test de Jarque-Bera arroja un p-value < 2.2e-16, lo que indica un rechazo categórico de la hipótesis nula de normalidad para la serie temporal del viento Levante, evidenciando la presencia de asimetría y curtosis significativamente diferentes de una distribución gaussiana. Este resultado es típico en datos meteorológicos de viento, donde las distribuciones suelen presentar sesgo positivo debido a la alta frecuencia de valores bajos de velocidad y la presencia de eventos extremos ocasionales, además del truncamiento natural en cero que caracteriza las mediciones de velocidad del viento. Aunque esta desviación de la normalidad no compromete la validez del modelado ARIMA, que es robusto ante violaciones de este supuesto en la serie original, sí sugiere que los intervalos de confianza de los pronósticos pueden requerir métodos no paramétricos para mayor precisión, siendo más crítica la evaluación de normalidad en los residuos del modelo final que en la serie temporal original.

```{r}
# Función de autocorrelación (ACF)
p2 <- ggAcf(ts_levante, lag.max = 100) +
  labs(title = "Función de Autocorrelación (ACF)") +
  theme_minimal()
p2
```

El análisis de la función de autocorrelación (ACF) para la serie temporal del viento Levante revela correlaciones estadísticamente significativas en los primeros 2-3 lags (p < 0.05), indicando que la velocidad del viento presenta persistencia a corto plazo con dependencia temporal limitada a pocos días. El decaimiento rápido de las correlaciones y la ausencia de picos regulares en lags superiores (7, 30, 365) sugiere una serie estacionaria sin componentes estacionales fuertes, comportamiento típico en series meteorológicas de viento. Las correlaciones que permanecen dentro de los límites de significancia estadística ( +/- 1.96/raiz-n) en lags mayores confirman la naturaleza de memoria corta del fenómeno, lo que indica que un modelo autorregresivo de orden bajo (AR(2) o AR(3)) sería apropiado para capturar la estructura de dependencia temporal, facilitando tanto el modelado como el pronóstico de la velocidad del viento Levante.


Descomposicion de la serie

Descomponer la serie temporal del viento Levante es fundamental antes de realizar análisis de correlación con el reclutamiento porque la descomposición permite separar claramente las distintas componentes que conforman la serie: tendencia, estacionalidad y ruido (componente irregular).

Esto es importante por varias razones:

**Aislar la señal relevante:** La variabilidad estacional y las tendencias a largo plazo pueden enmascarar o distorsionar la relación real entre el viento Levante y el reclutamiento. Por ejemplo, una tendencia creciente en el viento o patrones estacionales fuertes podrían inducir correlaciones espurias si no se controlan.

**Analizar relaciones específicas:** Al separar la serie en componentes, podemos investigar si el reclutamiento está correlacionado con la tendencia (por ejemplo, cambios a largo plazo en el viento), con la estacionalidad (patrones periódicos) o con las fluctuaciones residuales (ruido). Esto ayuda a entender mejor qué aspectos del viento Levante influyen en el reclutamiento.

**Mejorar modelos predictivos:** Modelos que usan series descompuestas o componentes filtradas suelen ser más robustos y con mayor poder explicativo porque evitan la confusión causada por la mezcla de señales.

**Cumplir supuestos estadísticos:** Muchos métodos estadísticos, como la correlación o regresión, asumen que las series son estacionarias o que las variables no están afectadas por tendencias o estacionalidades no controladas.

Por eso, la descomposición STL (que es flexible y puede adaptarse a cambios en la estacionalidad) y la descomposición clásica permiten obtener una visión clara y precisa de la dinámica del viento Levante, facilitando así una interpretación más acertada de cómo este factor climático puede afectar el reclutamiento de la población estudiada.


```{r}
# Descomposición STL (Seasonal and Trend decomposition using Loess)
stl_decomp <- stl(ts_levante, s.window = "periodic", t.window = NULL)

# Descomposición clásica
classical_decomp <- decompose(ts_levante, type = "additive")

# Crear gráficos de descomposición
p4 <- autoplot(stl_decomp) +
  labs(title = "Descomposición STL - Viento Levante") +
  theme_minimal()
p4
```
La descomposición STL (Seasonal and Trend decomposition using Loess) de la serie temporal del viento Levante revela una estructura temporal compleja caracterizada por una tendencia suave y gradual que muestra un incremento progresivo desde 2013 hasta mediados de 2015, seguido de una ligera disminución hacia 2016, con valores que oscilan entre 5.2 y 5.8 m/s. El componente estacional presenta fluctuaciones regulares con amplitud aproximada de ±2 m/s alrededor de la media, evidenciando patrones cíclicos anuales consistentes que sugieren variabilidad estacional en la intensidad del viento Levante, mientras que el componente de residuos muestra variaciones aleatorias de alta frecuencia con algunos picos ocasionales que podrían corresponder a eventos meteorológicos extremos no capturados por los componentes determinísticos. La magnitud relativamente pequeña de los residuos en comparación con la serie original indica que la descomposición STL logra capturar efectivamente la mayor parte de la variabilidad temporal, sugiriendo que la dinámica del viento Levante está dominada por procesos estacionales predecibles superpuestos a una tendencia de largo plazo moderada.


```{r}
# 6. ANÁLISIS DE COMPONENTES
# Extraer componentes
tendencia <- stl_decomp$time.series[,"trend"]
estacional <- stl_decomp$time.series[,"seasonal"]
residuos <- stl_decomp$time.series[,"remainder"]

# Estadísticas de componentes
cat("Varianza de componentes:\n")
cat("Serie original:", var(ts_levante, na.rm = TRUE), "\n")
cat("Tendencia:", var(tendencia, na.rm = TRUE), "\n")
cat("Estacional:", var(estacional, na.rm = TRUE), "\n")
cat("Residuos:", var(residuos, na.rm = TRUE), "\n")

# Proporción de varianza explicada
var_total <- var(ts_levante, na.rm = TRUE)
cat("\nProporción de varianza:\n")
cat("Tendencia:", round(var(tendencia, na.rm = TRUE)/var_total * 100, 2), "%\n")
cat("Estacional:", round(var(estacional, na.rm = TRUE)/var_total * 100, 2), "%\n")
cat("Residuos:", round(var(residuos, na.rm = TRUE)/var_total * 100, 2), "%\n")

# 7. ANÁLISIS DE RESIDUOS
cat("\n=== ANÁLISIS DE RESIDUOS ===\n")

# Test de Ljung-Box para independencia de residuos
lb_test <- Box.test(residuos, lag = 20, type = "Ljung-Box")
cat("Test Ljung-Box p-value:", lb_test$p.value, "\n")
if(lb_test$p.value > 0.05) {
  cat("Los residuos SON independientes (p > 0.05)\n")
} else {
  cat("Los residuos NO son independientes (p <= 0.05)\n")
}

# Gráficos de residuos
p5 <- autoplot(residuos) +
  labs(title = "Residuos de la Descomposición STL", y = "Residuos") +
  theme_minimal()

p6 <- ggAcf(residuos, lag.max = 50) +
  labs(title = "ACF de Residuos") +
  theme_minimal()

# Q-Q plot de residuos
residuos_df <- data.frame(residuos = as.numeric(residuos))
p7 <- ggplot(residuos_df, aes(sample = residuos)) +
  stat_qq() + stat_qq_line() +
  labs(title = "Q-Q Plot de Residuos", x = "Cuantiles teóricos", y = "Cuantiles muestrales") +
  theme_minimal()

# 8. DETECCIÓN DE VALORES ATÍPICOS usando descomposición STL
outliers <- tsoutliers(ts_levante)
cat("\nDetección de valores atípicos:\n")
if(length(outliers$index) > 0) {
  cat("Se detectaron", length(outliers$index), "valores atípicos\n")
  print(outliers)
} else {
  cat("No se detectaron valores atípicos significativos\n")
}

grid.arrange(p5, p6, p7, ncol = 2)


# 9. ANÁLISIS ESPECTRAL
cat("\n=== ANÁLISIS ESPECTRAL ===\n")

# Periodograma
spec_analysis <- spectrum(ts_levante, plot = FALSE)
freq_dominantes <- which(spec_analysis$spec == max(spec_analysis$spec))
periodo_dominante <- 1/spec_analysis$freq[freq_dominantes]
cat("Periodo dominante:", round(periodo_dominante, 2), "días\n")

# 10. MODELADO ARIMA AUTOMÁTICO
cat("\n=== MODELADO ARIMA ===\n")

# Auto ARIMA
auto_arima <- auto.arima(ts_levante, 
                         seasonal = TRUE, 
                         stepwise = FALSE, 
                         approximation = FALSE)
cat("Modelo ARIMA automático:\n")
print(auto_arima)

# Residuos del modelo ARIMA
checkresiduals(auto_arima)

# 11. PRONÓSTICOS
cat("\n=== PRONÓSTICOS ===\n")

# Pronóstico a 30 días
pronostico <- forecast(auto_arima, h = 30)
p8 <- autoplot(pronostico) +
  labs(title = "Pronóstico ARIMA - Viento Levante (30 días)",
       x = "Tiempo", y = "Velocidad (m/s)") +
  theme_minimal()
print(p8)

```


```{r}

# Exportar resultados principales
resultados_levante <- list(
  serie_temporal = ts_levante,
  descomposicion_stl = stl_decomp,
  modelo_arima = auto_arima,
  pronostico = pronostico,
  estadisticas = summary(ts_levante),
  tests = list(adf = adf_test, ljung_box = lb_test, jarque_bera = jb_test)
)
```

```{r}
viento_biologico <- tendencia + estacional
# Graficar el viento biológico (tendencia + estacional)
library(ggplot2)
library(forecast)
library(gridExtra)
library(lubridate)

# Combinar tendencia y componente estacional
viento_biologico <- tendencia + estacional

# Cargar paquetes necesarios
library(dplyr)
library(ggplot2)

# Obtener fechas reales a partir del tiempo decimal
fecha_inicio <- as.Date("2013-01-01")  # puedes ajustar si sabes la fecha real exacta
fechas <- seq(fecha_inicio, by = "day", length.out = length(ts_levante))

# Crear data.frame para ggplot u otras tareas
df_levante <- data.frame(
  fecha = fechas,
  valor = as.numeric(ts_levante)
)

# Vista previa
head(df_levante)

datos_plot <- data.frame(
  fecha = fechas,
  serie_original = as.numeric(ts_levante),
  tendencia = as.numeric(tendencia),
  estacional = as.numeric(estacional),
  viento_biologico = as.numeric(viento_biologico),
  residuos = as.numeric(residuos)
)

# 1. Gráfico principal: Serie original vs Viento biológico
p1 <- ggplot(datos_plot, aes(x = fecha)) +
  geom_line(aes(y = serie_original, color = "Serie Original"), alpha = 0.6, size = 0.5) +
  geom_line(aes(y = viento_biologico, color = "Viento Biológico"), size = 1.2) +
  scale_color_manual(values = c("Serie Original" = "lightgray", 
                               "Viento Biológico" = "darkblue")) +
  labs(title = "Viento Levante: Serie Original vs Componente Biológico",
       subtitle = "Viento biológico = Tendencia + Estacional (sin ruido de corto plazo)",
       x = "Fecha", 
       y = "Velocidad del viento (m/s)",
       color = "Serie") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, face = "bold"),
        legend.position = "bottom") +
  guides(color = guide_legend(override.aes = list(size = 2)))

# 2. Descomposición detallada
p2 <- ggplot(datos_plot, aes(x = fecha)) +
  geom_line(aes(y = tendencia, color = "Tendencia"), size = 1.2) +
  geom_line(aes(y = estacional, color = "Estacional"), size = 0.8) +
  geom_line(aes(y = viento_biologico, color = "Biológico"), size = 1.2) +
  scale_color_manual(values = c("Tendencia" = "red", 
                               "Estacional" = "green", 
                               "Biológico" = "darkblue")) +
  labs(title = "Componentes del Viento Biológico",
       subtitle = "Tendencia + Estacional = Viento Biológico",
       x = "Fecha", 
       y = "Velocidad del viento (m/s)",
       color = "Componente") +
  theme_minimal() +
  theme(legend.position = "bottom")

# 3. Comparación de variabilidad
p3 <- ggplot(datos_plot, aes(x = fecha)) +
  geom_ribbon(aes(ymin = viento_biologico - 0.5, ymax = viento_biologico + 0.5), 
              fill = "darkblue", alpha = 0.3) +
  geom_line(aes(y = serie_original), color = "gray60", alpha = 0.7) +
  geom_line(aes(y = viento_biologico), color = "darkblue", size = 1.2) +
  labs(title = "Viento Biológico con Banda de Confianza",
       subtitle = "Área sombreada: ±0.5 m/s alrededor del viento biológico",
       x = "Fecha", 
       y = "Velocidad del viento (m/s)") +
  theme_minimal()

# 4. Análisis por años
datos_plot$año <- year(datos_plot$fecha)
resumen_anual <- datos_plot %>%
  group_by(año) %>%
  summarise(
    original_media = mean(serie_original, na.rm = TRUE),
    biologico_media = mean(viento_biologico, na.rm = TRUE),
    original_sd = sd(serie_original, na.rm = TRUE),
    biologico_sd = sd(viento_biologico, na.rm = TRUE),
    .groups = 'drop'
  )

p4 <- ggplot(resumen_anual, aes(x = año)) +
  geom_line(aes(y = original_media, color = "Original"), size = 1) +
  geom_line(aes(y = biologico_media, color = "Biológico"), size = 1.2) +
  geom_point(aes(y = original_media, color = "Original"), size = 2) +
  geom_point(aes(y = biologico_media, color = "Biológico"), size = 3) +
  scale_color_manual(values = c("Original" = "gray60", "Biológico" = "darkblue")) +
  labs(title = "Promedios Anuales: Original vs Biológico",
       x = "Año", 
       y = "Velocidad media (m/s)",
       color = "Serie") +
  theme_minimal() +
  scale_x_continuous(breaks = resumen_anual$año)

# Mostrar gráficos
p_combinado <- grid.arrange(p1, p2, p3, p4, ncol = 2)
```


```{r}
# Estadísticas comparativas
cat("=== ESTADÍSTICAS COMPARATIVAS ===\n")
cat("Serie Original:\n")
cat("Media:", round(mean(datos_plot$serie_original, na.rm = TRUE), 2), "m/s\n")
cat("SD:", round(sd(datos_plot$serie_original, na.rm = TRUE), 2), "m/s\n")
cat("Rango:", round(range(datos_plot$serie_original, na.rm = TRUE), 2), "m/s\n")

cat("\nViento Biológico (Tendencia + Estacional):\n")
cat("Media:", round(mean(datos_plot$viento_biologico, na.rm = TRUE), 2), "m/s\n")
cat("SD:", round(sd(datos_plot$viento_biologico, na.rm = TRUE), 2), "m/s\n")
cat("Rango:", round(range(datos_plot$viento_biologico, na.rm = TRUE), 2), "m/s\n")

cat("\nReducción de variabilidad:\n")
reduccion_sd <- (1 - sd(datos_plot$viento_biologico, na.rm = TRUE) / sd(datos_plot$serie_original, na.rm = TRUE)) * 100
cat("Reducción SD:", round(reduccion_sd, 1), "%\n")

# Correlación
correlacion <- cor(datos_plot$serie_original, datos_plot$viento_biologico, use = "complete.obs")
cat("Correlación Original-Biológico:", round(correlacion, 3), "\n")

# Crear serie temporal del viento biológico
ts_viento_biologico <- ts(datos_plot$viento_biologico, 
                         start = c(year(min(datos_plot$fecha)), yday(min(datos_plot$fecha))),
                         frequency = 365.25)

cat("\n=== VIENTO BIOLÓGICO LISTO PARA CORRELACIÓN ===\n")
cat("Use 'ts_viento_biologico' o 'datos_plot$viento_biologico' para correlacionar con reclutamientos\n")

# Exportar datos
write.csv(datos_plot, "viento_biologico_diario.csv", row.names = FALSE)
write.csv(resumen_anual, "viento_biologico_anual.csv", row.names = FALSE)
cat("Datos exportados a archivos CSV\n")
```

### Series de Tiempo (ChatGPT)



1. **Agrega el preprocesamiento** para convertir tu `datos_levante` en una serie diaria (o semanal/mensual si prefieres).
2. **Hace análisis de autocorrelación (ACF/PACF)**.
3. **Descompone la serie temporal (STL)**.
4. **Prepara los datos agregados (por ejemplo, promedio diario)** que luego podrás correlacionar con el reclutamiento de coquina.


* Los datos están en formato horario (`POSIXct`) y en una tibble llamada `datos_levante`.
* Solo usaremos datos de viento tipo **"Levante"**.


```{r}
# Filtrar solo viento de tipo "Levante"
levante <- datos_levante %>%
  filter(tipo_viento == "Levante")

# Agregar a nivel diario: velocidad promedio por día
levante_diario <- levante %>%
  mutate(fecha = as.Date(fecha)) %>%
  group_by(fecha) %>%
  summarise(viento_promedio = mean(velocidad_viento, na.rm = TRUE)) %>%
  ungroup()
```

Visualización inicial de la serie

```{r}
ggplot(levante_diario, aes(x = fecha, y = viento_promedio)) +
  geom_line(color = "steelblue") +
  labs(title = "Velocidad promedio diaria del viento de Levante",
       x = "Fecha", y = "Velocidad (m/s)") +
  theme_minimal()
```

Convertir a serie temporal

```{r}
# Crear objeto ts
ts_levante <- ts(levante_diario$viento_promedio,
                 start = c(year(min(levante_diario$fecha)), yday(min(levante_diario$fecha))),
                 frequency = 365.25)

library(zoo)

# Serie diaria con fechas reales
ts_levante_zoo <- zoo(levante_diario$viento_promedio, order.by = levante_diario$fecha)

# Puedes hacer plot, ACF, STL usando zoo/forecast
plot(ts_levante_zoo)
# Comprobar si hay fechas faltantes
all_dates <- seq(min(levante_diario$fecha), max(levante_diario$fecha), by = "day")

# Completar fechas faltantes con NA (necesario para ts())
levante_completo <- data.frame(fecha = all_dates) %>%
  left_join(levante_diario, by = "fecha")

# Crear ts correctamente
ts_levante <- ts(levante_completo$viento_promedio,
                 start = c(2013, 1),  # asumiendo que parte del 1 de enero
                 frequency = 365.25)
length(ts_levante)           # Número total de observaciones
nrow(levante_diario)         # Días con datos
length(all_dates)            # Días posibles entre min y max
library(dplyr)
library(lubridate)

# 1. Crear secuencia completa de fechas diarias
fechas_completas <- seq(
  from = as.Date("2013-01-01"),
  to   = as.Date("2025-12-31"),
  by   = "day"
)

# 2. Agregar a nivel diario y completar fechas faltantes
levante_diario <- datos_levante %>%
  filter(tipo_viento == "Levante") %>%
  mutate(fecha = as.Date(fecha)) %>%
  group_by(fecha) %>%
  summarise(viento_promedio = mean(velocidad_viento, na.rm = TRUE)) %>%
  ungroup() %>%
  right_join(data.frame(fecha = fechas_completas), by = "fecha") %>%
  arrange(fecha)

# 3. Crear el objeto ts asegurando que tenga frecuencia diaria
ts_levante <- ts(levante_diario$viento_promedio,
                 start = c(2013, 1),
                 frequency = 365.25) 


```

Análisis de autocorrelación

```{r}
library(dplyr)
library(zoo)

# Asegúrate que 'fecha' sea Date (no POSIXct)
levante_diario <- levante_diario %>%
  mutate(fecha = as.Date(fecha))

# Crear secuencia completa de fechas
fechas_completas <- seq(min(levante_diario$fecha), max(levante_diario$fecha), by = "day")

# Combinar con la secuencia completa
serie_completa <- data.frame(fecha = fechas_completas) %>%
  left_join(levante_diario, by = "fecha")

# Crear objeto zoo con fechas completas
zoo_levante <- zoo(serie_completa$viento_promedio, order.by = serie_completa$fecha)

# Interpolar valores faltantes
zoo_interp <- na.approx(zoo_levante)

acf(zoo_interp, main = "Función de autocorrelación (ACF)")
pacf(zoo_interp, main = "Función de autocorrelación parcial (PACF)")


```

El gráfico de la Función de Autocorrelación (ACF) muestra una autocorrelación muy alta en el primer retardo (lag 1), superior a 0.8, lo que indica una fuerte dependencia temporal inmediata entre los valores diarios de la velocidad del viento de Levante. A partir del segundo retardo, los valores de autocorrelación caen rápidamente y se sitúan dentro del intervalo de confianza, lo que sugiere que, más allá del primer día, no hay una estructura temporal significativa persistente. Esto es típico de series con poca memoria a largo plazo y alta variabilidad diaria.

El gráfico de la Función de Autocorrelación Parcial (PACF) refuerza esta interpretación, mostrando un pico importante únicamente en el primer retardo, mientras que los retardos siguientes presentan valores bajos y dentro del rango de no significancia. Este patrón es característico de una estructura AR(1), donde el valor actual depende mayormente del día anterior, pero no directamente de días más lejanos. Esto implica que, para modelar esta serie, podría considerarse un modelo autorregresivo simple como punto de partida.



Descomposición de la serie temporal

```{r}
# STL: descomposición en tendencia, estacionalidad y residuo
ts_stl <- stl(ts_levante, s.window = "periodic")

# Gráfico de la descomposición
plot(ts_stl)
```


El gráfico de descomposición STL muestra la descomposición aditiva de la serie diaria de viento de Levante en sus tres componentes: tendencia, estacionalidad y residuo. En la primera franja se observa la serie original con alta variabilidad diaria. La componente estacional, en la segunda franja, revela un patrón repetitivo que parece reflejar cierta estacionalidad intraanual, posiblemente asociada a ciclos meteorológicos recurrentes, aunque con variabilidad de amplitud a lo largo del tiempo. Esto sugiere que hay cierta estructura estacional, aunque no muy pronunciada o perfectamente regular.

La tercera franja muestra la tendencia suavizada, la cual evidencia una leve pendiente ascendente entre 2013 y mediados de 2015, seguida por una caída y luego un aumento marcado hacia fines de 2015. Esto podría reflejar un cambio en la intensidad promedio del viento de Levante en ese periodo. Por último, el componente de residuo, en la cuarta franja, conserva una gran parte de la variabilidad diaria, lo que indica que buena parte de la señal es ruido o está influenciada por fenómenos no capturados ni por la estacionalidad ni por la tendencia, lo cual es esperable en datos meteorológicos con alta variabilidad a corto plazo.

Extraer componentes para usar en modelos posteriores

```{r}
# Extraer componentes en un data.frame
componentes <- ts_stl$time.series
df_componentes <- levante_diario %>%
  mutate(
    tendencia = as.numeric(componentes[, "trend"]),
    estacional = as.numeric(componentes[, "seasonal"]),
    residuo = as.numeric(componentes[, "remainder"])
  )

tail(df_componentes)
```

Guardar datos para modelos posteriores

```{r}
# Puedes guardar solo la tendencia, o la serie completa con componentes
write.csv(df_componentes, "levante_componentes.csv", row.names = FALSE)
```



Con el archivo `levante_componentes.csv`, puedes:

* Hacer correlaciones con tus datos de reclutamiento (`lm(reclutamiento ~ tendencia)`).
* Incluir `tendencia`, `estacionalidad` o incluso `residuo` como covariables en tus modelos lineales o no lineales.



### Trabajo futuro

Incorporar otras variables predictoras como temperatura, clorofila, entre otras...


\newpage

# Material Suplementario


El codigo fuente para el análisis exploratorio y manipulación de datos de viento y reclutamiento de coquina se encuentran disponibles en el repositorio de GitHub:  [wind_recruit_Dtrunculus](https://github.com/MauroMardones/wind-recruitment-Dtrunculus).

\newpage

# Referencias